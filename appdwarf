#!/bin/sh
set -e # exit on failure
IFS=$(printf '\n\t') # smarter ifs

apprun() {
    export PATH="$APPDIR"/bin:"$PATH"
    export LD_LIBRARY_PATH="$APPDIR"/lib64:"$APPDIR"/lib:"$LD_LIBRARY_PATH"
    exec "$APPDIR/$(basename "$ARGV0")" "$@"
}

header() {
    set -e
    APPDIR=$(mktemp -d)
    APPIMAGE="$(realpath "$0")"
    export APPDIR APPIMAGE ARGV0="$0" OWD="$PWD"
    dwarfs -o offset=auto -o tidy_strategy=swap -o workers="$(nproc)" -o debuglevel=warn "$0" "$APPDIR"
    trap 'fusermount -quz $APPDIR; rmdir $APPDIR' 0 1 2 3 6 14 15 EXIT
    "$APPDIR/AppRun" "$@"
    exit $?
}

printfunc() {
    echo '#!/bin/sh'
    sed -n "s/^ *//;/^$1() {$/,/^}$/p" "$0" | tail -n+2 | head -n-1
}

unappimage() {
    o=$(($(readelf -h "$1" | sed -e 's/[^0-9]//g;13p;18,19p;d' | sed -e 1a+ -e 2a*)))
    unsquashfs -o "$o" "$@" # calculate offset via ELF header
}

zzexe() {
    [ "$1" = "-p" ] && p="$2" && shift 2 # save prefix if present
    tmp=$(mktemp) # make tmp file to avoid io operations
    printfunc zzexe_header | sed -e "2s/);$/${1##*[./]})/" -e "7s/^/$p /" > "$tmp"
    zstdmt -cq19 "$@" >> "$tmp"
    mv "$tmp" "$1"
    chmod +x "$1"
    exit
}

zzexe_header() {
    dir=$(dirname "$0") out=$(mktemp -t .zzXXXX.)
    awk 'f;/^exit \$res$/{f=1}' "$0" | head -c-1 | zstd -cd > "$out"
    chmod +x "$out"
    ln -s "$out" "$dir"
    trap 'rm "$out" "$dir/$(basename "$out")"'  0 1 2 3 6 14 15 EXIT
    "$dir/$(basename "$out")" "$@"
    res=$?
    rm "$out" "$dir/$(basename "$out")"
    exit $res
}

case "$1" in
    -a )
        printfunc apprun > "$2"
        chmod +x "$2"
        exit ;;
    -b )
        printfunc apprun | sed '4s#/#/bin/#' > "$2"
        chmod +x "$2"
        exit ;;
    -d )
        d=dwarfs-root # just to keep line shorter, extract if file is dwarfs
        dwarfsck -d0 -i"$2" && mkdir $d && dwarfsextract -o $d -i "$2" && exit
        tmp=$(mktemp) # make tmp file to avoid io operations
        awk 'f;/^exit \$res$/{f=1}' "$2" | head -c-1 | zstd -cd > "$tmp"
        mv "$tmp" "$2"
        chmod +x "$2"
        exit ;;
    -p )
        zzexe "$@" ;;
    -z)
        shift
        zzexe "$@" ;;
    --version | -v )
        tput setaf 2; echo appdwarf 2022.11.14
        tput setaf 6; echo Built by July 🏳️‍🌈; exit ;;
    -* | '' )
        echo "Usage: appdwarf [option] [APP/FILE/FOLDER/URL] [compression options]"
        echo "  -a [file]       Write example AppRun to file and exit"
        echo "  -b [file]       Write example AppRun with bin subdir to file and exit"
        echo "  -d [file]       Decompress an appdwarf image or zzexe'd file"
        echo
        echo "  -p [prefix]     zzexe a file with prefix"
        echo "  -z              zzexe a file"
        echo
        echo "  -h, --help      Print this help text"
        echo "  -v, --version   Print the appdwarf version"; exit ;;
esac

if [ ! -d "$1" ]; then # directory doesn't exist, see if this is an appimage
    if [ ! -f "$1" ]; then # file doesn't exist, see if this is a url
        if ! echo "$1" | grep -q / ; then # AppImageHub
            echo "Checking AppImageHub for this program..."
            app=https://github.com/AppImage/appimage.github.io/raw/master/apps/$1.md
            shift
            set -- "$(curl -L "$app" | grep -o https.\*releases | sed 's|/releases$||')" "$@"
        elif ! echo "$1" | grep https ; then # GitHub in Author/Repo format
            app=$1
            shift
            set -- "https://github.com/$app" "$@"
        fi

        if echo "$1" | grep -q 'https://github.com/[^/]*/[^/]*/*$'; then # GitHub url
            echo "Assuming this is a GitHub repo..."
            app="$(echo "${1%/}"/releases | sed 's|github.com|api.github.com/repos|')"
            shift
            set -- "$(curl "$app" | grep -v arm | grep -om1 https.\*AppImage)" "$@"
        fi

        app=$(basename "$1") # actually try to get the appimage
        if aria2c -x16 -s16 "$1" -o "$app" || wget "$1" -O "$app"; then
            shift
            set -- "$app" "$@"
        else
            tput setaf 1; echo "No valid remote or local input found. Exiting..." >&2
            rm -f "$app"; exit 1
        fi
    fi

    # this is a file, but it might be an existing dwarfs image
    if dwarfsck -d0 -i"$1"; then
        set -- "$@" --recompress=none
    elif test "$(hexdump -n11 -e'"%x"' "$1")" = 464c457f1010224941; then
        echo "AppImage found. Converting..." # appimage magic matched
        app="$(basename "$1" .AppImage)"
        unappimage "$1"
        rm -rf "$1" "$app"
        shift
        set -- "$app" "$@"
        mv squashfs-root "$1"
    else
        tput setaf 4; echo "$1 is not an AppImage, it will be zzexe'd"
        zzexe "$@"
    fi
fi

head="$(mktemp)"
printfunc header > "$head"

mkdwarfs -o "$(realpath "$1").sh" -B5 --header "$head" -i "$@"
rm -rf "$head" "$1"
chmod +x "$(realpath "$1").sh"
